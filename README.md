# üìì Phase 5: Transition from H2 to PostgreSQL

## üéØ Objective

In Phase 5, we replace the in-memory database (H2) used for development and demo purposes with a persistent PostgreSQL database for production and containerized environments.
This transition ensures data durability, real-world compatibility, and alignment with the 12-Factor App principles regarding config management, dev/prod parity, and backing services.

We will:

- Understand why we move from **H2 ‚Üí PostgreSQL**
- Explore **Spring Profiles** (`dev`, `docker`)
- Review configuration changes (`application.yml`, `tasks-service-dev.yml` / `tasks-service.yml`)
- Examine SQL scripts (`schema.sql`, `schema-h2.sql`, `data.sql`)
- Test the integration locally and in Docker Compose

---

## üß© 1. Why Move from H2 to PostgreSQL?

| Aspect      | H2 (In-Memory)                       | PostgreSQL (Persistent)                  |
|-------------|--------------------------------------|------------------------------------------|
| Storage     | Memory only (resets on restart)      | Disk-based, durable                      |
| Performance | Extremely fast, small                | Slightly slower but production-grade     |
| SQL Dialect | Close to ANSI, limited features      | Full SQL, JSON, functions, indexing      |
| Persistence | Ephemeral                            | Persistent across restarts               |
| Usage       | Ideal for dev/testing                | Ideal for production and staging         |

### ‚öôÔ∏è Key Motivation

- Realistic production behavior (DDL, constraints, transactions)  
- Compatible with cloud environments (AWS RDS, Azure PostgreSQL, etc.)  
- Ensures schema consistency between Docker and Kubernetes deployments  
- Enables complex queries and performance monitoring

---

## üß± 2. Multi-Environment Strategy (Spring Profiles)

Spring Boot supports environment-specific configurations via profiles.  
In Phase 5 we maintain two primary profiles:

| Profile | Purpose | Database | Source of config |
|---|---|---|---|
| `dev` | Local testing and development | H2 (in-memory) | `tasks-service-dev.yml` |
| `docker` | Production-like environment with persistence | PostgreSQL | `config-repo/tasks-service.yml` via Config Server |

---

## ‚öôÔ∏è 3. Configuration Files Overview

### üîπ `application.yml` (shared)
```yaml
spring:
  application:
    name: tasks-service

eureka:
  client:
    service-url:
      defaultZone: ${EUREKA_URL:http://eureka:8761/eureka}
  instance:
    instance-id: ${spring.application.name}:${server.port:${random.value}}:${random.uuid}

spring:
  profiles:
    active: docker  # Default when running in containers
```

### üîπ `tasks-service-dev.yml` (local development)
```yaml
spring:
  datasource:
    url: jdbc:h2:mem:tasksdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL
    driver-class-name: org.h2.Driver
    username: sa
    password:
  jpa:
    hibernate:
      ddl-auto: none
    properties:
      hibernate.dialect: org.hibernate.dialect.H2Dialect
  sql:
    init:
      mode: always
      schema-locations: classpath:schema-h2.sql
      data-locations: classpath:data.sql
  h2:
    console:
      enabled: true
      path: /h2-console
```

> üß† This profile allows quick local testing without PostgreSQL. Developers can use STS/IntelliJ to run the service instantly.

### üîπ `tasks-service.yml` (Docker / Production)
```yaml
spring:
  datasource:
    url: jdbc:postgresql://postgres:5432/tasksdb
    username: ${DB_USER:tasks}
    password: ${DB_PASS:tasks}
  jpa:
    hibernate:
      ddl-auto: none
    properties:
      hibernate.dialect: org.hibernate.dialect.PostgreSQLDialect
  sql:
    init:
      mode: always
      schema-locations: classpath:schema.sql
      data-locations: classpath:data.sql
```

‚úÖ These values are loaded from GitHub through the Config Server, which now points to the `phase-4` tag as its configuration label.

---

## üßÆ 4. Schema and Initialization Scripts

### üóÇÔ∏è `schema-h2.sql` (Development)
```sql
CREATE TABLE IF NOT EXISTS task (
  id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title        VARCHAR(140) NOT NULL,
  description  CLOB,
  status       VARCHAR(32) NOT NULL DEFAULT 'OPEN',
  assignee     VARCHAR(140),
  project_id   BIGINT,
  created_at   TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at   TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

### üóÇÔ∏è `schema.sql` (Production / PostgreSQL)
```sql
CREATE TABLE IF NOT EXISTS task (
  id           BIGSERIAL PRIMARY KEY,
  title        VARCHAR(140) NOT NULL,
  description  TEXT,
  status       VARCHAR(32) NOT NULL DEFAULT 'OPEN',
  assignee     VARCHAR(140),
  project_id   BIGINT,
  created_at   TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at   TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

Both scripts maintain identical structures to ensure dev-prod parity.

---

## üß† 5. Running with Profiles

### ‚ñ∂Ô∏è Local Development (H2)
```bash
export SPRING_PROFILES_ACTIVE=dev
mvn spring-boot:run -pl :tasks-service
```

Access:

- H2 Console ‚Üí http://localhost:8081/h2-console  
- Tasks API ‚Üí http://localhost:8081/tasks

### ‚ñ∂Ô∏è Docker Deployment (PostgreSQL)
```bash
docker compose up -d
docker compose logs -f tasks-service
```

---

## üîÑ 6. Config Server Update

**Phase 4 (antes):**
```yaml
spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/smartlearningci/cloud_java
          searchPaths: config-repo
          default-label: main
```

**Agora (Phase 5):**
```yaml
spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/smartlearningci/cloud_java
          searchPaths: config-repo
          default-label: phase-4
```

---

## ‚öôÔ∏è 7. Relation to the 12-Factor App Principles

| Principle | Implementation in Phase 5 |
|---|---|
| Config | Externalized via Spring Cloud Config (Git-based) |
| Backing services | PostgreSQL treated as an attached resource |
| Dev/Prod parity | Identical schema across profiles |
| Disposability | Containers can be rebuilt with deterministic DB state |
| Build, Release, Run | Profiles define runtime behavior cleanly |
| Environment parity | Config files separate local (H2) vs Docker (Postgres) |
| Logs | Still centralized via Docker and Spring Boot Actuator |

---

## üß™ 8. Validation Tests

### ‚úÖ Verify Database Initialization
```bash
docker exec -it postgres psql -U tasks -d tasksdb -c '\dt'
```

Should list:
```
 public | task | table | tasks
```

### ‚úÖ Verify Application Connectivity
```bash
curl http://localhost:8080/api/tasks
```

### ‚úÖ Verify Local H2
```bash
curl http://localhost:8081/tasks
```

---

## üß≠ Conclusion

The transition from H2 to PostgreSQL transforms our demo architecture into a production-ready system.
We achieve reliable persistence, externalized configuration, and profile-based flexibility without losing the ability to run locally.
This marks a key milestone toward a 12-Factor compliant cloud-native microservices platform.
